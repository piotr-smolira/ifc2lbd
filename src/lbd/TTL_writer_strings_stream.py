"""Streaming TTL writer for IFC files using ifcopenshell.stream2"""

from collections import defaultdict
from typing import Any, Dict
from pathlib import Path
import ifcopenshell
import ifcopenshell.ifcopenshell_wrapper as wrapper


def build_entity_type_map(input_ifc_path: str) -> dict:
    """
    First pass: Build mapping of entity ID -> entity type.
    This allows us to resolve references correctly in the second pass.
    
    Args:
        input_ifc_path: Path to IFC file
        
    Returns:
        Dictionary mapping entity IDs to their types {1: 'IfcOwnerHistory', 2: 'IfcPerson', ...}
    """
    entity_types = {}
    for entity_dict in ifcopenshell.stream2(input_ifc_path):
        entity_id = entity_dict.get('id')
        entity_type = entity_dict.get('type')
        if entity_id and entity_type:
            entity_types[entity_id] = entity_type
    return entity_types


def format_turtle_value(val, inst_prefix, xsd_prefix, entity_types=None):
    """
    Format value for Turtle syntax.
    
    Args:
        val: Value to format
        inst_prefix: Instance namespace prefix (not used currently)
        xsd_prefix: XSD namespace prefix (not used currently)
        entity_types: Optional dict mapping entity IDs to types for proper reference formatting
    """
    val_type = type(val)
    
    if val_type is str:
        return f'"{val}"'
    elif val_type is int:
        return f'"{val}"^^xsd:integer'
    elif val_type is float:
        return f'"{val}"^^xsd:double'
    elif val_type is bool:
        return f'"{str(val).lower()}"^^xsd:boolean'
    elif isinstance(val, dict) and 'ref' in val:
        # Handle reference dictionaries from stream2
        ref_id = val['ref']
        if entity_types and ref_id in entity_types:
            # Writing inst:IfcPerson_3 instead of inst:Entity_3
            return f"inst:{entity_types[ref_id]}_{ref_id}"
        else:
            # Fallback if no type map provided
            return f"inst:Entity_{ref_id}"
    else:
        return f'"{str(val)}"'


def string_writer_mini_ifcOWL_stream(input_ifc_path: str, output_ttl_path: str, namespaces: Dict[str, str]):
    """
    Stream an IFC file and write to Turtle TTL format (mini ifcOWL style).
    
    Uses two-pass approach:
    1. First pass: Build lightweight ID->type mapping
    2. Second pass: Stream and write with correct entity references
    """
    BASE = namespaces.get("BASE", "http://example.org/base#")
    INST = namespaces["INST"]
    XSD = namespaces["XSD"]

    # FIRST PASS: Build instance type mapping
    entity_types = build_entity_type_map(input_ifc_path)

    # SECOND PASS: Write TTL with correct references
    with open(output_ttl_path, 'w', encoding='utf-8') as f:
        f.write(f"# Turtle TTL output generated by LBD writer (streaming mode).\n")
        f.write(f"# baseURI: {BASE}\n")
        f.write(f"# imports: {namespaces['MINIIFC']}\n")
        f.write("\n")
        f.write(f"BASE <{BASE}> .\n")
        for prefix, uri in namespaces.items():
            f.write(f"PREFIX {prefix.lower()}: <{uri}> .\n")
        f.write("\n")
        f.write(f"inst:\ta\towl:Ontology ;\n")
        f.write(f"\towl:imports\tifc: .\n\n")

        for entity_dict in ifcopenshell.stream2(input_ifc_path):
            entity_type = entity_dict.get('type')
            entity_id = entity_dict.get('id')
            
            if not entity_type or not entity_id:
                continue
            
            subj = f"inst:{entity_type}_{entity_id}"
            pred_obj = defaultdict(list)
            
            for attr_name, attr_value in entity_dict.items():
                if attr_name in ('type', 'id') or attr_value is None:
                    continue
                
                pred = f"ifc:{attr_name}"
                
                if isinstance(attr_value, (list, tuple)):
                    for item in attr_value:
                        if item is None:
                            continue
                        obj = format_turtle_value(item, INST, XSD, entity_types)
                        pred_obj[pred].append(obj)
                else:
                    obj = format_turtle_value(attr_value, INST, XSD, entity_types)
                    pred_obj[pred].append(obj)
            
            f.write(f"{subj} a ifc:{entity_type}")
            
            if pred_obj:
                f.write(" ;\n")
                predicates = list(pred_obj.items())
                for i, (pred, objs) in enumerate(predicates):
                    objects_str = " , ".join(objs)
                    if i < len(predicates) - 1:
                        f.write(f"\t{pred} {objects_str} ;\n")
                    else:
                        f.write(f"\t{pred} {objects_str} .\n\n")
            else:
                f.write(" .\n\n")




# This one is still not functioning. So just a placeholder.

def string_writer_ifcOWL_stream(input_ifc_path: str, output_ttl_path: str, namespaces: Dict[str, str]):
    """
    Stream an IFC file and write to Turtle TTL format following full ifcOWL.
    
    Uses two-pass approach:
    1. First pass: Build lightweight ID->type mapping
    2. Second pass: Stream and write with correct entity references
    """

    pass