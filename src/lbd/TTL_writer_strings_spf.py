""" String TTL serializer"""

from collections import defaultdict
from typing import Any, Dict, List, Tuple, Optional, Union, Callable
from pathlib import Path
import ifcopenshell
import ifcopenshell.ifcopenshell_wrapper as wrapper

def format_turtle_value(val, p, o):
    """
    Format value for Turtle syntax.
    """
    val_type = type(val)
    
    if val_type is str:
        return f'"{val}"'
    elif val_type is int:
        return f'"{val}"^^xsd:integer'
    elif val_type is float:
        return f'"{val}"^^xsd:double'
    elif val_type is bool:
        return f'"{str(val).lower()}"^^xsd:boolean'
    elif isinstance(val, ifcopenshell.entity_instance):
        return f"inst:{val.is_a()}_{val.id()}"
    else:
        return f'"{str(val)}"'

def string_writer_mini_ifcOWL(model, output_path: str, namespaces: Dict[str, str]):
    """
    Write IFC model to Turtle TTL format.
    
    Args:
        model: IfcOpenShell model to serialize
        output_path: Path to output TTL file
        namespaces: Dictionary of prefix -> URI mappings (e.g., {"IFC": "...", "INST": "...", "XSD": "..."})
    """
    BASE = namespaces.get("BASE", "http://example.org/base#")
    INST = namespaces["INST"]
    XSD = namespaces["XSD"]

    schema = wrapper.schema_by_name(model.schema_identifier)

    with open(output_path, 'w', encoding='utf-8') as f:
        # Write prologue comments:
        f.write(f"# Turtle TTL output generated by LBD writer.\n")
        f.write(f"# baseURI: {BASE}\n")
        f.write(f"# imports: {namespaces['MINIIFC']}\n")
        f.write("\n")
        f.write(f"BASE <{BASE}> .\n")
        for prefix, uri in namespaces.items():
            f.write(f"PREFIX {prefix.lower()}: <{uri}> .\n")
        f.write("\n")

        f.write(f"inst:\ta\towl:Ontology ;\n")
        f.write(f"\towl:imports\tifc: .\n\n")

        for idx, inst in enumerate(model):
            #print(instance_schema)
            # Subject IRI
            subj = f"inst:{inst.is_a()}_{inst.id()}"
            pred_obj = defaultdict(list)

            for attr_idx, value in enumerate(inst):
                if value is None:
                    continue
                # Predicate
                pred = f"ifc:{inst.attribute_name(attr_idx)}"

                # Values
                if isinstance(value, (list, tuple)):
                    for item in value:
                        if item is None:
                            continue
                        obj = format_turtle_value(item, INST, XSD)
                        pred_obj[pred].append(obj)
                else:
                    obj = format_turtle_value(value, INST, XSD)
                    pred_obj[pred].append(obj)
        
            f.write(f"{subj} a ifc:{inst.is_a()}")

            if pred_obj:
                f.write(" ;\n")
                predicates = list(pred_obj.items())
                for i, (pred, objs) in enumerate(predicates):
                    objects_str = " , ".join(objs)
                    if i < len(predicates) - 1:
                        f.write(f"\t{pred} {objects_str} ;\n")
                    else:
                        f.write(f"\t{pred} {objects_str} .\n\n")
            else:
                f.write(" .\n\n")


# This one is still not functioning.

def string_writer_ifcOWL(model, output_path: str, namespaces: Dict[str, str]):
    """
    Write IFC model to Turtle TTL format following full ifcOWL.
    
    In ifcOWL, predicates are named as: ifc:{AttributeName}_{DeclaredTypeName}
    For example: ifc:GlobalId_IfcGloballyUniqueId, ifc:Name_IfcLabel

    Args:
        model: IfcOpenShell model to serialize
        output_path: Path to output TTL file
        namespaces: Dictionary of prefix -> URI mappings (e.g., {"IFC": "...", "INST": "...", "XSD": "..."})
    """

    pass